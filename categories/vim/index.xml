<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vim on feileo</title>
    <link>https://at7h.com/categories/vim/</link>
    <description>Recent content in Vim on feileo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 26 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://at7h.com/categories/vim/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>武器修炼之 Neo/vim 与 Tmux</title>
      <link>https://at7h.com/posts/my-dotfiles/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/my-dotfiles/</guid>
      <description>古人云：工欲善其事，必先利其器。 一直以来，我都觉得应该好好修炼一个自己趁手的『武器』，这篇文章跟大家谈一谈我的一点点修炼感受。 你可以选择修炼 vim、emacs 等编辑器，如果你不喜欢折腾也可以直接使用 IDE。这个话题貌似比较敏感，很多人都在讨论，我个人感觉完全是个人审美或是爱好而已，说到底『武器』只是辅助工具，只要用的顺手，能很好够满足自己的功能、审美等需求即可，最重要的还是自己本身的『武功』，如果你『武功』足够高，不需要借助工具帮助提高效率，不要补全不要 lint 这那的，用『记事本』也不耽误你写出牛逼的代码。 我的选择是做个 vimer。修炼路且长，下面来谈一下我自己的一点入坑感受和建议，希望可以帮助那些还在迷茫的想要入门的童鞋。老鸟就跳过吧，感兴趣的话可以关注下我的配置，提提建议、意见，交流交流，共同进步。 入坑建议 作为一个爱『折腾』的人，学生时代也用过一些主流的 IDE，最后弃用的原因就是觉得太重了，太多的功能用不上，更不想那么多这那的窗口挡住我的代码 😂。在用了一段时间 sublime 之后，最终决定开始入坑 vim，后来因为异步、floating window 等切到了 neovim，当然这些现在 vim 也都支持了，再后来接触到 tmux，就圆满了 😎。 Tmux 是一款优秀的终端复用软件，由于很长一段时间我的开发都是登录远程主机上进行的，这时候 tmux 神器简直就让你爽到起飞。本地开发的话，多个项目终端之间切换，也是非常有用。跟 vim 类似，刚开始也是有一定的上手使用和配置难度，中间放弃了一次，但是入坑之后，就就就就，爽的飞起~ 作为一个流行了三十多年的非常优秀的编辑器，我是非常喜欢它的设计哲学的，说的直白一点就是它的工作模式吧。还有一个很重要的方面就是，每一次你在折腾配置折腾插件的时候，它总是时不时的能给你带来惊喜，也许很小的一点改动却可以大幅提高你使用的『幸福度』。 很多人觉得它的上手难度比较大，学习曲线有些陡峭，看别人用的很溜，自己上手就不知所措，那么多快捷键、命令怎么记得住，配置好难搞哦等等，慢慢就弃坑了。 个人觉得是这样，刚开始的时候你得想清楚你学它的目的，是真正的喜欢想修炼自己的『武器』？还是就是看人家用好溜，也想学上一手装个 B 呢？一直在说，工具只是工具，辅助你高效率的写代码而已，如果你自身『武功』足够高，用『记事本』也不耽误你写出牛逼的代码，要毛补全要毛 Lint。就是说，首先你得搞清楚了是为了什么，IDE 好好的为啥非要辛苦折腾这样那样配置呢，得明白你是为了满足什么需求解决什么问题。 Sorry，貌似跑题了。回到正题，刚开始没办法，就是硬着头皮上，上手用，刚开始你可能，哦不对，是肯定是觉得真难用，是的，没有任何配置的情况下确实不怎么好用，所以你就要想办法让它『好用起来』。对于配置，我是建议自己慢慢来『攒』你的自己配置，一行一行自己来搞，这个配置是干嘛的这个插件是干嘛的，搞清楚，一点一点来，积累形成一套适合自己的风格。可以并且鼓励去参考一些别人的优秀的配置、解决方案，但是要弄懂，不要一把梭照搬过来。 当然现在有很多很成熟的产品级的解决方案比如 spaceVim，你可以直接拿来根据教程快速的上手用起来，但刚开始它对你就像是个黑盒子，哪里出了问题，或者你想修改点东西都可能无从下手。 Vim 里面的东西还是比较复杂的，个人觉得你是日常使用的话，肯定是比较注重实际的使用，没必要一开始就像学习一门课程一样系统的学，今天学完明天也许就忘了，更没必要去记那些这样那样的命令、快捷键。就直接上手干就完了（当然也不是说一点也不看教程，最开始肯定还是要先看一些简单的入门帖子，必备技能还是要学一下子的，不然刚开始就没法玩儿），遇到不会搞的就查，查文档，问搜索引擎，用的多了自然就会了，按的多了自然就记住了，长期的肌肉记忆根本就不需要过脑子想这个怎么按，时间长了，你遇到的问题、需求多了，自然就入门了。对插件也是一样，不要一开始就去完全照搬别人的配置，一大堆插件一把梭都装上，也不知道一个个是干嘛的，最好还是根据自己的需要一个一个来，好好看下每个插件仓库的文档，看下怎么使用。 Tmux 也是一样，可以额先看下基础的一些帖子或者官方文档，然后主要是上手用，就干就完了。配置也一样，也是建议自己搞，不要一开始全部照搬，每个人习惯不一样，别人喜欢的未必就是你喜欢的，『拿来』可以，但是前提是你要能吸收理解，能驾驭。 1. Neo/vim 下查看文档可以输入 : 进入 COMMAND 模式 help，这里的文档也就是它的官方文档，这里是翻译中文文档。 2. Tmux 可以看官方仓库的 Getting-Started，像我这种英文不怎么能看明白的还是要再去搜一些相关的介绍文章看看。 不要放弃，硬着头发干，等真正用起来之后，相信我，你肯定会爱上它们的 😏 😏 ~ 我的分享 最后，分享下我的配置： https://github.com/at7h/dots 对你有用的话，请帮忙点个 Star，感谢 😊 当然，也十分欢迎大家来交流自己的想法、心得、配置 …… 大家有问题欢迎评论留言，我会第一时间回复。</description>
    </item>
    
    <item>
      <title>闲侃 sys.path 与 buildout 实践</title>
      <link>https://at7h.com/posts/py-syspath/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/py-syspath/</guid>
      <description>这篇文章我们来讨论下 Python 中的 sys.path，以及其在 buildout 中的应用与实践，最后分享下在 neo/vim 中给 python-mode 和 coc-python 添加自定义本地 Python 包路径的方法。 sys.path Python 中的 sys.path 是一个字符串列表，用于指定 Python Runtime 的模块搜索路径。 &amp;gt;&amp;gt;&amp;gt; import sys &amp;gt;&amp;gt;&amp;gt; sys.path [ &amp;#39;&amp;#39;, &amp;#39;/usr/local/lib/python27.zip&amp;#39;, &amp;#39;/usr/local/lib/python2.7&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-darwin&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac/lib-scriptpackages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-tk&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-old&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-dynload&amp;#39;, &amp;#39;/Users/jiawei/.local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages/install-1.3.3-py2.7.egg&amp;#39; ] 该列表由以下三个部分组成，在程序启动时，会从以下三个方面进行初始化: 1. 第一部分 sys.path[0] 是你当前调用 python 解释器的脚本的目录，也就是你当前的 Python 项目路径，如果是在 REPL 环境中，其为空字符串 &amp;quot;&amp;quot;。 2. 第二部分是开发者可以修改控制的，通过几种方式读取开发者定义的模块路径，例如通过读取环境变量 PYTHONPATH 等，下面具体介绍。 3. 最后一部分是你 Python 安装相关的默认环境。 当我们在程序中导入 import m 时，可能会遇到 ImportError: No module named m 这种类似的包无法导入的问题时，原因在于它所在的路径不在 sys.path 里，下面我将列举向 sys.path 添加自定义模块路径几种方法。 1. 通过创建 .pth 文件，将目录列出来，例如： /my/prodir1 /my/prodir2 但这种方式我们通常是不提倡的，关于更多如何使用 .pth 文件拓展 sys.path 的介绍可以阅读 site 模块的描述。 2. 通过设置环境变量 PYTHONPATH，写过 Go 的朋友应该都比较熟悉，类似于 Golang 中有 GOROOT 和 GOPATH。 export PYTHONPATH=/my/prodir1:/my/prodir2 现在再来看看我们的 sys.path &amp;gt;&amp;gt;&amp;gt; import sys &amp;gt;&amp;gt;&amp;gt; sys.path [ &amp;#39;&amp;#39;, &amp;#39;/my/prodir1&amp;#39;, &amp;#39;/my/prodir2&amp;#39;, &amp;#39;/usr/local/lib/python27.zip&amp;#39;, &amp;#39;/usr/local/lib/python2.7&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-darwin&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac&amp;#39;, &amp;#39;/usr/local/lib/python2.7/plat-mac/lib-scriptpackages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-tk&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-old&amp;#39;, &amp;#39;/usr/local/lib/python2.7/lib-dynload&amp;#39;, &amp;#39;/Users/jiawei/.local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages&amp;#39;, &amp;#39;/usr/local/lib/python2.7/site-packages/install-1.3.3-py2.7.egg&amp;#39; ] 3. 还有一种方式是写脚本来手动添加，在进入你程序的 work runtime 之前将路径插入到 sys.path中， 这种方式可以做到项目级，比较灵活： import sys sys.path.insert(0, &amp;#39;/my/prodir1&amp;#39;) sys.path.insert(0, &amp;#39;/my/prodir2&amp;#39;) 当然，上面只是一个简单的示例，实践中需要尽量避免硬编码，导致添加错误的路径。 buildout 对于一个 Python 开发者来说，虚拟环境工具你一定不陌生，例如 virtualenv，virtualenvwrapper，pipenv 等，它们通常提供了一个相对隔离的环境来存放和管理你需要的第三方包，并为你设置好 sys.path。不对，貌似有点跑题了，关于虚拟环境的工作原理我将在后面单独分享，下面请出本节的主角大哥大 buildout。 Buildout 是一个 Python 项目的自动化构建打包工具，通过它我们可以为大型系统创建复杂但可重用的设置。其主要根据配置将项目的依赖以 egg 包的形式全部归在统一的一个 eggs 目录下，这样就不用依赖任何外部的资源，比虚拟环境来得更彻底。egg 包 类似于 Java 中的 jar 包，想了解更多介绍的同学可以阅读这篇文章。 关于 buildout 的更多介绍和以及如何配置，官方文档上都有详细的介绍，而且因为本文的主题是 sys.path，所以这里就不赘述了。 这里我们主要关心它包的组织，eggs 会生成到你项目下的 buildout.cfg 配置中的 eggs-directory 目录下，而一般我们并不需要额外去配置，默认会生成在当前项目的根目录下，为你的项目使用。 当然 buildout 也支持在多个项目之间共享 eggs。这需要你新建 $HOME/.buildout/default.cfg 文件，设置用户级的默认配置： [buildout] eggs-directory = ~/.buildout/eggs download-cache = ~/.buildout/downloads 除此之外，你还可以通过每个 parts 下的 extra-paths 配置你本地的包： [buildout] parts = app [app] recipe = zc.recipe.egg interpreter = python eggs = my-pro-name extra-paths = ${buildout:directory}/my-extra-pkg 好，回到主题，既然是将依赖包打在项目里，所以要正确启动服务，buildout 肯定要将项目的所有依赖包 eggs 中的包路径以及 extra-paths 加入到 sys.path 中，它采用的方式是我们上面说的第三种，我们可以打开 bin 下生成的可执行文件一看便知： #!/Path/to/your/local/python import os, sys base = os.path.dirname(os.path.abspath(os.path.realpath(__file__))) base = os.path.dirname(base) sys.path[0:0] = [ base, &amp;#39;/path/to/local/pro/eggs/pkg1.egg&amp;#39;, &amp;#39;/path/to/local/pro/eggs/pkg2.egg&amp;#39;, # ... &amp;#39;/path/to/local/pro/my-extra-pkg&amp;#39; ] # ... 如果打包过程中，有一些包是你已经安装了，也就是在上面谈到的 sys.path 的第三部分的中的某个路径下，比如 /usr/local/lib/python2.7/site-packages, 那么在打包过程中就不会生成相应的 egg 包了，所以会在上述 sys.path 也会加上这个路径，因为 buildout 必须保证项目依赖包的完备性。 vim 插件支持 buildout 虽然很完美，但这也给 neo/vim 下的 Python 环境搭建带来了一点麻烦，据我所知目前的一些 Python 相关的插件并没有直接支持 buildout 的（PyCharm 是支持的，直接配置即可），所以并不能正确识别 buildout 的配置来加载我们项目的那些依赖包，在 rope init 或者 lint 时会报错找不到包，因此代码跳转补全等基础功能都会受到影响。所以我们必须要自己来处理这个问题，将上述依赖包加入到其运行时环境中。 当然你可以直接通过我们上述的几种方法来实现，但这不是我推荐的，因为配置环境变量等等都是全局的，幸好目前我用的几个插件都支持自定义包的拓展配置，比如 python-mode 和 coc-python。 1. 对于 pymode pymode 提供了 g:pymode_paths 数组来存放额外的包路径，所以在你的 pymode 配置中加入如下配置即可： if $BUILDOUT_EGGS_PATH != &amp;#39;&amp;#39; let g:pymode_paths = reverse(split(globpath($BUILDOUT_EGGS_PATH, &amp;#39;*&amp;#39;), &amp;#39;\n&amp;#39;)) else let g:pymode_paths = reverse(split(globpath(getcwd().&amp;#39;/eggs&amp;#39;, &amp;#39;*&amp;#39;), &amp;#39;\n&amp;#39;)) endif 在上面的配置中，如果你的 buildout 使用了多个项目共享 eggs 模式的话，为 BUILDOUT_EGGS_PATH 配置共享 eggs 的路径即可: export BUILDOUT_EGGS_PATH=/path/to/buildout/eggs/path 而如果并不是共享 eggs 的模式，那么项目的包都会在当前目录下的 eggs 中，就不用任何配置，配置会走到 else 逻辑自动获取包路径。 对于上述配置在 extra-paths 下的包可以: let g:pymode_paths = g:pymode_paths + reverse(split(getcwd().&amp;#39;/my-extra-pkg&amp;#39;, &amp;#39;\n&amp;#39;) 2. 对于 coc-python 同样的，coc-python 也提供了相应的配置： python.autoComplete.extraPaths: List of paths to libraries and the like that need to be imported by auto complete engine. E.g. when using Google App SDK, the paths are not in system path, hence need to be added into this list., default: [] 所以我们只需在 coc-settings.json 中加入相应配置即可，我们依旧使用上面的例子： { // ... &amp;#34;python.autoComplete.extraPaths&amp;#34;:[ &amp;#34;/path/to/local/pro/eggs/pkg1.egg&amp;#34;, &amp;#34;/path/to/local/pro/eggs/pkg2.egg&amp;#34;, &amp;#34;my-extra-pkg&amp;#34; ] // ... } 加入配置之后可以在 neo/vim COMMAND 模式下使用 CocInfo 命令来查看 path 的查找详情。 感兴趣的同学可以查看我的配置，同时也欢迎大家评论留言，与我交流。</description>
    </item>
    
    <item>
      <title>在 tmux 环境中使用 tmux-256color</title>
      <link>https://at7h.com/posts/install-tmux256-formac/</link>
      <pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/install-tmux256-formac/</guid>
      <description>在 macOS 中，我们 iTerm2 中的 terminal color 一般都设置为 xterm-256color，这没毛病，但问题是它不能在 tmux 环境中使用: $TERM should be &amp;quot;screen-256color&amp;quot; or &amp;quot;tmux-256color&amp;quot; in tmux. Colors might look wrong. 为此，我们可以在 zshrc 中加上这样一段配置： if [[ $TMUX != &amp;#34;&amp;#34; ]] then export TERM=&amp;#34;tmux-256color&amp;#34; else export TERM=&amp;#34;xterm-256color&amp;#34; fi 而在 tmux 环境中一般默认使用系统自带的 screen-256color，这在大多数情况是够用的，但是它不支持任何斜体字体样式，所以在 Vim 中类似代码高亮这种就会很有问题。 为此，我们可以在 tmux.conf 中加上设置： set -g default-terminal &amp;#34;tmux-256color&amp;#34; set-option -a terminal-overrides &amp;#34;,*256col*:RGB&amp;#34; 新建一个 session 测试一下： tnew test # tmux new -s test 发现报错: can&#39;t find terminal definition for tmux-256color。 原因是系统默认是没有 tmux-256color 的，需要我们手动安装，加上相应的 terminfo 就可以了。 tmux-256color 详细安装教程：Installing tmux-256color for macOS 感兴趣的同学可以参考我的配置，欢迎大家评论留言，与我交流。</description>
    </item>
    
  </channel>
</rss>