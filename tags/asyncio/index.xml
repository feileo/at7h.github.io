<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>asyncio on feileo</title>
    <link>https://at7h.com/tags/asyncio/</link>
    <description>Recent content in asyncio on feileo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 18 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://at7h.com/tags/asyncio/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Helo 快速上手指南</title>
      <link>https://at7h.com/posts/helo/</link>
      <pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/helo/</guid>
      <description>其中，u.update(name=&amp;quot;Daisy&amp;rdquo;) 与 u.name = &amp;ldquo;Daisy&amp;rdquo; 类似，都是只在内存里修改对象的属性，不同的是 u.update() 还会返回一个包含本次变更的中间结果，对其执行 await xxx.apply() 则会将这些变更应用到数据库里。 Helo 是本人业余开发的一个简单小型低级别的异步(asyncio) Python ORM。它几乎没有什么概念，非常直白，容易上手使用。 此处去往项目仓库 ，欢迎使用、提出意见或贡献代码 😊 Helo 可以在你的异步应用中帮助你轻松的构建出富有表达力的常用 SQL 语句，你只需以友好的对象化 API 来操作数据，而不用关心 SQL 语句编写、数据处理等细节。 请注意：使用异步 ORM 并不完全意味着可以使你的应用变快，而且有可能会使你的应用变得复杂。继续之前，你可以先阅读下 SQLAlchemy 作者 Mike Bayer 的 这篇博客文章。 本篇上手指南主要介绍以下方面: 安装 helo 模型声明 建立连接 数据操作 在 quart 应用中使用 helo 其他补充 开始使用 安装 helo 可以通过以下两种方式: 1. 安装 pypi 的稳定发布版本, 在终端中运行此命令: $ pip install helo 2. 从最新的源码安装 $ git clone https://github.com/at7h/helo.git $ cd helo $ python setup.py install 安装完成后就开始下面的入坑之旅了 😈 。 使用 helo, 首先你需要引入 helo 并使用 helo.G 实例化一个全局变量，假定称其为 db: import helo db = helo.G() db 是一个全局单例对象，下面的介绍中我们将多次使用到它。 模型声明 使用 helo 声明模型很简单，只需从 helo.Model 继承即可。下面给出几个模型声明的简单的例子： class Person(helo.Model): id = helo.BigAuto() name = helo.VarChar(length=45, null=False) class User(Person): email = helo.Email(default=&amp;#39;&amp;#39;) password = helo.VarChar(length=100, null=False) create_at = helo.Timestamp(default=helo.ON_CREATE) class Meta: indexes = [helo.K(&amp;#39;idx_ep&amp;#39;, [&amp;#39;email&amp;#39;, &amp;#39;password&amp;#39;])] class Employee(Person): department = helo.Smallint() salary = helo.Float(default=0) class Post(helo.Model): id = helo.Auto(comment=&amp;#39;auto increment pk&amp;#39;) title = helo.VarChar(length=100) content = helo.Text(encoding=helo.ENCODING.UTF8MB4) author = helo.Int(default=0) create_at = helo.Timestamp(default=helo.ON_CREATE) update_at = helo.Timestamp(default=helo.ON_UPDATE) class Meta: indexes = [ helo.K(&amp;#39;idx_title&amp;#39;, &amp;#39;title&amp;#39;), helo.K(&amp;#39;idx_author&amp;#39;, &amp;#39;author&amp;#39;), ] 内部类 Meta 可用于指定 db_name, table_name, engine, indexes, charset, comment 等 Table 的元属性。 class Meta: db = &amp;#39;db_name&amp;#39; name = &amp;#39;table_name&amp;#39; engine = helo.ENGINE.innodb charset = helo.ENCODING.utf8mb4 indexes = [] comment = &amp;#39;table comment&amp;#39; 其中 table_name 默认为 model 类名的 snake_case 风格名称，engine 默认为 InnoDB，charset 默认为 utf8mb4。 建立连接 前面的模型声明只是定义了模型与真实表结构的映射关系，并非实际在数据库中创建了这些表结构。为此，我们需要先使用 helo 来与数据库建立连接，这里我们创建一个 MySQL 的数据库实例： &amp;gt;&amp;gt;&amp;gt; await db.bind(&amp;#39;mysql://user:pwd@localhost:3306/helo&amp;#39;) 或者传递配置参数： &amp;gt;&amp;gt;&amp;gt; await db.bind(user=&amp;#39;user&amp;#39;, password=&amp;#39;pwd&amp;#39;, db=&amp;#39;helo&amp;#39;) 如果你设置了环境变量 HELO_DATABASE_URL，那么你不用再传递 url: &amp;gt;&amp;gt;&amp;gt; await db.bind() 如果你想自定义 KEY 的值，可以在初始化 db 时通过 env_key 参数来设置: db = helo.G(env_key=&amp;quot;YOUR_ENV_KEY&amp;quot;) bind 实际上为我们创建了一个数据库连接池： &amp;gt;&amp;gt;&amp;gt; db.state {&amp;#39;minsize&amp;#39;: 1, &amp;#39;maxsize&amp;#39;: 15, &amp;#39;size&amp;#39;: 1, &amp;#39;freesize&amp;#39;: 1} bind 给我们提供了很多关键字参数来允许我们自定义设置，详见 helo.db.Pool 类。例如： &amp;gt;&amp;gt;&amp;gt; await db.bind(&amp;#39;mysql://user:pwd@127.0.0.1:3306/db&amp;#39;, maxsize=10, connect_timeout=15) 已经创建的连接池对象将是一个全局的单例对象，也就是说如果你已经为你的应用程序调用 bind 绑定了数据库，在此之前如果你没有使用 unbind 进行解绑，你将不能再继续使用 bind 再次绑定另一个数据库，否则你将会得到一个 helo.err.DuplicateBinding 错误。 如果你需要显式地断开与数据库的连接，关闭连接池，可以使用 unbind: &amp;gt;&amp;gt;&amp;gt; await db.unbind() 在小型的脚本中你可以使用 db.binder 来自动处理上下文： &amp;gt;&amp;gt;&amp;gt; async with db.binder(): ... pass 数据操作 与数据库建立了连接之后，我们需要在数据库创建我们的表，以便于接下来进行数据的操作。 在真正的应用中，数据库表的设计创建与维护是单独分开，一般由专门的 DBA 来管理。当然 helo 也提供了基础的 DDL 支持。 下面我们在数据库创建它们： &amp;gt;&amp;gt;&amp;gt; await db.create_tables([User, Employee, Post]) 在应用项目中，我们通常将所有的模型声明单独放在一个模块中，在此假设模块名为 models，则可以使用 create_all 为模块中所有的 model 创建表： &amp;gt;&amp;gt;&amp;gt; from your.application import models &amp;gt;&amp;gt;&amp;gt; await db.create_all(models) 当然你也可以使用 Model 的方法来单独创建: &amp;gt;&amp;gt;&amp;gt; await User.create() Helo 提供了基本的操作数据库中数据的能力，支持丰富的可组合的逻辑运算表达，你可以轻松的完成富有表达力的 queries，以实现通过对象化的 API 来构建你想要的 SQL 语句(DML 和 DQL)的能力。 下面示例基本的增删改查的操作。 增 使用 helo 你可以有多种插入数据的方式选择，我们从创建一个 User 对象开始: user = User(name=&amp;#39;at7h&amp;#39;, password=&amp;#39;1111&amp;#39;) print(user.name, user.password) # at7h, 1111 # Now user.id is None, because it is not saved to the database assert user.id is None 此时的 user 仅是内存中的一个对象，你需要通过 save 方法持久化到数据库中： user_id = await user.save() assert user_id == user.id == 1 我们可以修改它，并保存更改： user.name = &amp;#39;at8h&amp;#39; user.email = &amp;#39;g@at7h.com&amp;#39; user_id = await user.save() assert user_id == user.id == 1 请注意： 目前 save 操作是通过 MySQL REPLACE 语句实现，其根据对象的 PRIMARY KEY 属性或 UNIQUE KEY 属性的值来决定是否插入新行，请谨慎使用！该实现计划在后续版本中优化。 推荐使用下面几种方式来插入数据。 方法 add, madd 可以用来添加单条或多条数据，它们是 insert, minsert 的简单快捷方式： user_id = await User.add(name=&amp;#39;bobo&amp;#39;, password=&amp;#39;2222&amp;#39;) # Or: user_id = await User.add({&amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;, &amp;#39;password&amp;#39;: &amp;#39;2222&amp;#39;}) print(user_id) # 2 users = [{&amp;#39;name&amp;#39;: &amp;#39;mingz&amp;#39;, &amp;#39;password&amp;#39;: &amp;#39;3333&amp;#39;}, {&amp;#39;name&amp;#39;: &amp;#39;xy69z&amp;#39;, &amp;#39;password&amp;#39;: &amp;#39;4444&amp;#39;}] # Or using user object list: # users = [User(name=&amp;#39;mingz&amp;#39;, password=&amp;#39;3333&amp;#39;), # User(name=&amp;#39;xy69z&amp;#39;, password=&amp;#39;4444&amp;#39;)] count = await User.madd(users) print(count) # 2 方法 insert 和 minsert 是最正确的数据插入姿势，它们可以胜任多种数据形式，它们将返回一个 Insert 对象，要执行此操作，请不要忘了写 do() 哦 😉： ret = await User.insert(name=&amp;#39;poper&amp;#39;, password=&amp;#39;5555&amp;#39;).do() # Or: ret = await User.insert({&amp;#39;name&amp;#39;: &amp;#39;bingo&amp;#39;, &amp;#39;password&amp;#39;: &amp;#39;8888&amp;#39;}).do() assert ret.affected == 1 assert ret.last_id == 5 print(ret) # (1, 5) # Inserting multiple employees = [ {&amp;#39;name&amp;#39;: &amp;#39;at7h&amp;#39;, &amp;#39;department&amp;#39;: 1}, {&amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;, &amp;#39;department&amp;#39;: 2}, ] ret = await Employee.minsert(employees).do() print(ret) # (2, 1) # Specify row tuples columns the tuple values correspond to posts = [ (&amp;#39;post1&amp;#39;, 1), (&amp;#39;post2&amp;#39;, 2), ] ret = await Post.minsert( posts, columns=[Post.title, Post.author] ).do() print(ret) # (2, 1) 使用 insert_from 支持表间数据填充： select = User.select(User.name).where(User.id.in_([3, 4, 5])) ret = await Employee.insert_from(select, [Employee.name]).do() print(ret) # (3, 3) 查 Helo 也有多种获取数据的方式选择，如简单获取单条数据可以使用 get 方法： # By id user = await User.get(1) assert isinstance(user, User) print(user.id, user.name, user.password) # 1, at7h, 1111 # Or by query assert (await User.get(User.name == user.name)) == user 获取多条数据可以使用 mget 方法： # By id list uid_list = [1, 2, 3] users = await User.mget(uid_list) print(users.count) # 3 print(users) # [&amp;lt;User object at 1&amp;gt;, &amp;lt;User object at 2&amp;gt;, &amp;lt;User object at 3&amp;gt;] # Specify columns users = await User.mget(uid_list, columns=[User.id, User.name]) assert users[0].password is None # Or by query users = await User.mget((User.id &amp;lt; 2) | (User.name == &amp;#39;mingz&amp;#39;)) print(users) # [&amp;lt;User object at 1&amp;gt;, &amp;lt;User object at 3&amp;gt;] 同样的，方法 get 和 mget 也是 select 的简单快捷版本，其只适合于已知主键或查询条件比较简单的场景，更多的时候我们还是需要使用 select。 使用 select 方法可以帮助你以对象化 API 的方式轻松的构造你的 DQL，其支持丰富的可组合的逻辑条件表达式。 users = await User.select().order_by( User.id.desc() ).limit(3).offset(2).all() print(users) # [&amp;lt;User object at 5&amp;gt;, &amp;lt;User object at 4&amp;gt;, &amp;lt;User object at 3&amp;gt;] 方法 all() 以及下面提到的 get(), first(), rows(), paginate() 等方法类似于上面提到的 do()，都用于驱动执行此次查询，不要忘了哦。 比如我需要知道有没有使用 gmail 邮箱的用户： is_exist = await User.select().where( User.email.endswith(&amp;#39;gmail.com&amp;#39;) ).exist() print(is_exist) # False 比如我想知道 2019 年 7 月以来共新增了多少用户： user_count = await User.select().where( User.create_at &amp;gt; datetime(2019, 7, 1) ).count() print(user_count) # 4 再比如我们需要分页的获取今年写了 Python(title) 相关文章的用户： users = await User.select().where( User.id.in_( Post.select(Post.author).where( Post.update_at &amp;gt; datetime(2019, 1, 1), Post.title.contains(&amp;#39;Python&amp;#39;) ).order_by( Post.update_at.desc() ) ) ).paginate(1, 10) print(users) # [&amp;lt;User object at 1&amp;gt;] 再比如我们想知道每个用户都写了多少篇文章： user_posts = await User.select( User.name, helo.F.COUNT(helo.SQL(&amp;#39;1&amp;#39;)).as_(&amp;#39;posts&amp;#39;) ).join( Post, helo.JOINTYPE.LEFT, on=(User.id == Post.author) ).group_by( User.name ).rows(100) print(user_posts) # [{&amp;#39;name&amp;#39;: &amp;#39;at7h&amp;#39;, &amp;#39;posts&amp;#39;: 1}] 如上所示，我们可以通过 helo.F 来使用 SQL 函数，比如我需要计算出每个月所有雇员薪资的总和： salary_sum = await Employee.select( helo.F.SUM(Employee.salary).as_(&amp;#39;salary_sum&amp;#39;) ).scalar() print(salary_sum) # 30000.0 改 接下来，让我们尝试对数据库中的数据做一些修改操作。 比如你要更改某一位雇员的薪资 😋： ret = await Employee.update(salary=20000).where( Employee.name == &amp;#39;at7h&amp;#39; ).do() print(ret.affected) # 1 或者，整体涨工资啦 👏： ret = await Employee.update( salary=Employee.salary + 1000 ).where( (Employee.department.in_([1, 2])) | (Employee.name == &amp;#39;at7h&amp;#39;) ).do() 删 最后我们来尝试删除表中的数据。 第一种方式，你可以使用 model 对象的 remove 方法来删除它对应于数据库中这一行的数据： user = User(name=&amp;#39;at7h&amp;#39;, password=&amp;#39;1111&amp;#39;) await user.save() user = await User.get(user_id) print(user.id) # 1 await user.remove() user = await User.get(user_id) print(user) # None 另一种更为通常的方式是使用 delete 方法： ret = await Post.delete().where( Post.create_at &amp;lt; datetime(2010, 1, 1) ).limit( 100 ).do() 请注意： 永远不要忘记写 where 子句，是不是整个表都不想要了 😟 ？ Replace 另外，helo 支持 MySQL REPLACE 语句，提供了 replace 和 mreplace 两个方法，其用法与 insert 和 minsert 类似。当然，在使用它们之前你需要了解 MySQL REPLACE 语句的工作原理。 Quart 应用 如果你正在使用 quart, 一个最小的应用示例是: import quart import helo app = quart.Quart(__name__) app.config[&amp;#34;HELO_DATABASE_URL&amp;#34;] = &amp;#34;mysql://user:password@127.0.0.1:3306/db&amp;#34; db = helo.G(app) @app.route(&amp;#39;/api/users&amp;#39;) async def users(): await User.insert( name=&amp;#39;at7h&amp;#39;, email=&amp;#39;g@test.com&amp;#39;, password=&amp;#39;xxxx&amp;#39; ).do() user_list = await User.select().all(False) return quart.jsonify(user_list) app.run() 此时你不需要再显示的执行 db.bind，binding 操作将会在你应用的第一个请求之前自动完成。 启动此服务: $ curl http://127.0.0.1:5000/api/users [{&amp;#34;email&amp;#34;:&amp;#34;g@test.com&amp;#34;,&amp;#34;id&amp;#34;:1,&amp;#34;name&amp;#34;:&amp;#34;at7h&amp;#34;,&amp;#34;password&amp;#34;:&amp;#34;xxxx&amp;#34;}] 其他 Model Iteration Helo 中的 Model 和 Select 都支持迭代，helo 会自动帮你处理分页问题，以避免频繁的 IO 操作和过大的数据量获取。 async for post in Post: print(post) # &amp;lt;Post object at 1&amp;gt; # &amp;lt;Post object at 2&amp;gt; # &amp;lt;Post object at 3&amp;gt; # &amp;lt;Post object at 4&amp;gt; users = User.select().where(User.id &amp;lt; 5).order_by(User.id.desc()) async for user in users: print(user) # &amp;lt;User object at 4&amp;gt; # &amp;lt;User object at 3&amp;gt; # &amp;lt;User object at 2&amp;gt; # &amp;lt;User object at 1&amp;gt; Row Type 当你使用 select 获取数据时，helo 默认会将行数据包装成为对应的 Model 对象，但是，当你使用了 helo.F 函数和 join 时可能会放弃加载到 Model 对象而使用原始的 helo.adict 字典。当然，你也可以通过 wrap 参数来显式指定使用字典类型的 row type。在大型项目中，这可能会显著提高速度并减少内存的使用。 users = await User.select(User.id, User.name).limit(2).all(wrap=False) print(users) # [{&amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;at7h&amp;#39;}, {&amp;#39;id&amp;#39;: 2, &amp;#39;name&amp;#39;: &amp;#39;bobo&amp;#39;}] assert users[0].name == &amp;#39;at7h&amp;#39; employee = await Employee.select().order_by( Employee.salary.desc() ).first(False) print(employee) # {&amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;at7h&amp;#39;, &amp;#39;department&amp;#39;: 1, &amp;#39;salary&amp;#39;: 15000.0} SQL 执行 SQL 有时你可能迫不得已想要执行一些原始的 SQL 语句，那么你可以使用 db.raw 函数来实现。 await db.raw(&amp;#34;SELECT * FROM `user` WHERE `id` &amp;lt; %s;&amp;#34;, params=[10]) 查看 SQL 为方便调试，有时候需要查看执行的 SQL，在 helo 中，你可以: 第一种方式，在初始化 db 时，设置 debug 为 True 即可，这样你将在日志输出中看到执行过的所有 SQL 语句。 db = helo.G(debug=True) 第二种方式主要是方便学习和调试，你可以使用 repr 函数(或在 REPR 环境中)和 str 函数来查看 Insert, Update, Select 等对象，我们拿上面的示例来举个例子： &amp;gt;&amp;gt;&amp;gt; q1 = Employee.update( ... salary=Employee.salary + 1000 ... ).where( ... (Employee.department.in_([1, 2])) | (Employee.name == &amp;#39;at7h&amp;#39;) ... ) &amp;gt;&amp;gt;&amp;gt; q1 Query(UPDATE `employee` SET `salary` = (`salary` + %s) WHERE ((`department` IN %s) OR (`name` = %s)); % ((1000.0,), (1, 2), &amp;#39;at7h&amp;#39;)) &amp;gt;&amp;gt;&amp;gt; q2 = User.select( ... User.name, helo.F.COUNT(helo.SQL(&amp;#39;1&amp;#39;)).as_(&amp;#39;posts&amp;#39;) ... ).join( ... Post, helo.JOINTYPE.LEFT, on=(User.id == Post.author) ... ).group_by( ... User.name ... ) &amp;gt;&amp;gt;&amp;gt; print(q2) SELECT `t1`.`name`, COUNT(1) AS `posts` FROM `user` AS `t1` LEFT JOIN `post` AS `t2` ON (`t1`.`id` = `t2`.`author`) GROUP BY `t1`.`name`; % () 本篇上手指南就到此结束。 十分欢迎大家的使用，有任何问题可随时与我交流或到 项目仓库 反馈，欢迎以任何形式提出任何问题或建议。 感谢 🤝</description>
    </item>
    
    <item>
      <title>Python3 协程(coroutine)介绍</title>
      <link>https://at7h.com/posts/coroutine/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://at7h.com/posts/coroutine/</guid>
      <description>目前 Python 语言的协程从实现来说可分为两类： 一种是基于传统生成器的协程，叫做 generator-based coroutines，通过包装 generator 对象实现。 另一种在 Python 3.5 版本 PEP 492 诞生，叫做 native coroutines，即通过使用 async 语法来声明的协程。 本文主要介绍第二种，第一种基于生成器的协程已在 Python 3.8 中弃用，并计划在 Python 3.10 中移除。本文是「介绍」，就先不讨论太多实现原理的东西，感兴趣的童鞋可以继续关注后面的文章。 协程(coroutine) 首先，来看一个非常简单的例子： import asyncio async def c(): await asyncio.sleep(1) return &amp;#39;Done 👌&amp;#39; 这个被 async 修饰的函数 c 就是一个协程函数，该函数会返回一个协程对象。 In [1]: asyncio.iscoroutinefunction(c) Out[1]: True In [2]: c() Out[2]: &amp;lt;coroutine object c at 0x107b0f748&amp;gt; In [3]: asyncio.iscoroutine(c()) Out[3]: True 一般来说，协程函数 c 应具有以下特点： 一定会返回一个协程对象，而不管其中是否有 await 表达式。 函数中不能再使用 yield from。 函数内部可通过 await 表达式来挂起自身协程，并等待另一个协程完成直到返回结果。 await 表达式后面可以跟的一定是一个可等待对象，而不仅仅是协程对象。 不可在 async 修饰的协程函数外使用 await 关键字，否则会引发一个 SyntaxError。 当对协程对象进行垃圾收集时，如果从未等待过它，则会引发一个 RuntimeWarning（如果你刚开始写 async，那你一定遇得到，不经意间就会忘掉一个 await)。 下面分别介绍下上面提到的两个概念，可等待对象和协程对象。 可等待对象(awaitable) 我们来看 collections.abc 模块中对 Awaitable 类的定义： class Awaitable(metaclass=ABCMeta): __slots__ = () @abstractmethod def __await__(self): yield @classmethod def __subclasshook__(cls, C): if cls is Awaitable: return _check_methods(C, &amp;#34;__await__&amp;#34;) return NotImplemented 可见，可等待对象主要实现了一个 __await__ 方法。且该方法必须返回一个迭代器(iterator) ①，否则将会引发一个 TypeError。 注意：主要实现是因为 await 表达式需要跟老的基于生成器的协程相兼容，即通过使用 types.coroutine() 或 asyncio.coroutine() 装饰器返回的生成器迭代器对象(generator iterator)也属于可等待对象，但它们并未实现 __await__ 方法。 协程对象(Coroutine) 同样的，我们来看 collections.abc 模块中对 Coroutine 类的定义： class Coroutine(Awaitable): __slots__ = () @abstractmethod def send(self, value): &amp;#34;&amp;#34;&amp;#34;Send a value into the coroutine. Return next yielded value or raise StopIteration. &amp;#34;&amp;#34;&amp;#34; raise StopIteration @abstractmethod def throw(self, typ, val=None, tb=None): &amp;#34;&amp;#34;&amp;#34;Raise an exception in the coroutine. Return next yielded value or raise StopIteration. &amp;#34;&amp;#34;&amp;#34; if val is None: if tb is None: raise typ val = typ() if tb is not None: val = val.with_traceback(tb) raise val def close(self): &amp;#34;&amp;#34;&amp;#34;Raise GeneratorExit inside coroutine. &amp;#34;&amp;#34;&amp;#34; try: self.throw(GeneratorExit) except (GeneratorExit, StopIteration): pass else: raise RuntimeError(&amp;#34;coroutine ignored GeneratorExit&amp;#34;) @classmethod def __subclasshook__(cls, C): if cls is Coroutine: return _check_methods(C, &amp;#39;__await__&amp;#39;, &amp;#39;send&amp;#39;, &amp;#39;throw&amp;#39;, &amp;#39;close&amp;#39;) return NotImplemented 由上可知，由于继承关系，协程对象是属于可等待对象的。 除了协程 Coroutine 对象外，目前常见的可等待对象还有两种：asyncio.Task 和 asyncio.Future，下文中介绍。 协程的执行可通过调用 __await__() 并迭代其结果进行控制。当协程结束执行并返回时，迭代器会引发 StopIteration 异常，并通过该异常的 value 属性来传播协程的返回值。下面看一个简单的例子： In [4]: c().send(None) Out[4]: &amp;lt;Future pending&amp;gt; In [5]: async def c1(): ...: return &amp;#34;Done 👌&amp;#34; ...: In [6]: c1().send(None) Out[6]: StopIteration: Done 👌 运行 协程的运行需要在一个 EventLoop 中进行，由它来控制异步任务的注册、执行、取消等。其大致原理是： 把传入的所有异步对象(准确的说是可等待对象，如 Coroutine，Task 等，见下文)都注册到这个 EventLoop 上，EventLoop 会循环执行这些异步对象，但同时只执行一个，当执行到某个对象时，如果它正在等待其他对象（I/O 处理） 返回，事件循环会暂停它的执行去执行其他的对象。当某个对象完成 I/O 处理后，下次循环到它的时候会获取其返回值然后继续向下执行。这样以来，所有的异步任务就可以协同运行。 EventLoop 接受的对象必须为可等待对象，目前主要有三种类型即 Coroutine, Task 和 Future。 下面简单的介绍下 Task 和 Future： Future 是一种特殊的低级的可等待对象，用来支持底层回调式代码与高层 async/await 式的代码交互，是对协程底层实现的封装，其表示一个异步操作的最终结果。它提供了设置和获取 Future 执行状态或结果等操作的接口。Future 实现了 __await__ 协议，并通过 __iter__ = __await__ 来兼容老式协程。一般来说，我们不需要关心这玩意儿，日常的开发也是不需要要用到它的。如有需要，就用其子类 Task。 Task 用来协同的调度协程以实现并发，并提供了相应的接口供我们使用。 创建一个 Task 非常简单： In [6]: loop = asyncio.get_event_loop() In [7]: task = loop.create_task(c()) In [8]: task Out[8]: &amp;lt;Task pending coro=&amp;lt;c() running at &amp;lt;ipython-input-1-3afd2bbb1944&amp;gt;:3&amp;gt;&amp;gt; In [9]: task.done() Out[9]: False In [10]: task.cancelled() Out[10]: False In [11]: task.result() Out[11]: InvalidStateError: Result is not set. In [12]: await task Out[12]: &amp;#39;Done 👌&amp;#39; In [13]: task Out[13]: &amp;lt;Task finished coro=&amp;lt;c() done, defined at &amp;lt;ipython-input-1-3afd2bbb1944&amp;gt;:3&amp;gt; result=&amp;#39;Done 👌&amp;#39;&amp;gt; In [14]: task.done() Out[14]: True In [15]: task.result() Out[15]: &amp;#39;Done 👌&amp;#39; In [16]: task = loop.create_task(c()) In [17]: task.cancel() Out[17]: True In [18]: await task Out[18]: CancelledError: 上面说到，协程的运行需要在一个 EventLoop 中进行，在 Python 3.7 之前，你只能这么写 😔 : In [19]: loop = asyncio.get_event_loop() In [20]: loop.run_until_complete(c()) Out[20]: &amp;#39;Done 👌&amp;#39; In [21]: loop.close() Python 3.7 及以上版本可以直接使用 asyncio.run() 👏 : In [22]: asyncio.run(c()) Out[22]: &amp;#39;Done 👌&amp;#39; 并发 有些童鞋可能有疑问了，我写好了一个个协程函数，怎样才能并发的运行 🤔 ？ asyncio 提供了相应的两个接口：asyncio.gather 和 asyncio.wait 来支持: async def c1(): await asyncio.sleep(1) print(&amp;#39;c1 done&amp;#39;) return True async def c2(): await asyncio.sleep(2) print(&amp;#39;c2 done&amp;#39;) return True async def c12_by_gather(): await asyncio.gather(c1(), c2()) async def c12_by_awit(): await asyncio.wait([c1(), c2()]) In [23]: asyncio.run(c12_by_gather()) c1 done c2 done In [24]: asyncio.run(c12_by_awit()) c1 done c2 done 其它 上面我们介绍了 PEP 492 coroutine 的基础使用，同时 PEP 492 也相应提出了基于 async with 和 async for 表达式的异步上下文管理器(asynchronous context manager)和异步迭代器(asynchronous iterator)。 下面的介绍的示例将基于 Python 可迭代对象, 迭代器和生成器 里的示例展开，建议感兴趣的同学可以先看下这篇文章。 异步上下文管理器 在 Python 中，我们常会通过实现 __enter__() 和 __exit__() 方法来实现一个上下文管理器： In [1]: class ContextManager: ...: ...: def __enter__(self): ...: print(&amp;#39;enter...&amp;#39;) ...: ...: def __exit__(slef, exc_type, exc_val, exc_tb): ...: print(&amp;#39;exit...&amp;#39;) ...: In [2]: with ContextManager(): ...: print(&amp;#39;Do something...&amp;#39;) ...: enter... Do something... exit... 同样的，在异步编程时我们可以通过实现 __aenter__() 和 __aexit__() 方法来实现一个上下文管理器，并通过 async with 表达式来使用。 In [1]: class AsyncContextManager: ...: ...: async def __aenter__(self): ...: print(&amp;#39;async enter...&amp;#39;) ...: ...: async def __aexit__(slef, exc_type, exc_val, exc_tb): ...: print(&amp;#39;async exit...&amp;#39;) ...: In [2]: async with AsyncContextManager(): ...: print(&amp;#39;Do something...&amp;#39;) ...: async enter... Do something... async exit... 异步迭代 在之前的文章 Python 可迭代对象, 迭代器和生成器 中，我们介绍了通过实现 __iter__() 方法来实现一个可迭代对象，通过实现迭代器协议 __iter__() 和 __next__() 方法来实现一个迭代器对象。下面我们改造下之前的例子，实现一个异步的版本。 class AsyncLinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.findall(self.PATTERN, text) def __aiter__(self): return AsyncLinkIiterator(self.links) class AsyncLinkIiterator: def __init__(self, links): self.links = links self.index = 0 async def _gen_link(self): try: link = self.links[self.index] self.index += 1 except IndexError: link = None return link def __aiter__(self): return self async def __anext__(self): link = await self._gen_link() if link is None: raise StopAsyncIteration return link In [7]: async for s in AsyncLinkFinder(TEXT): ...: print(s) https://blog.python.org http://feedproxy.google.com/~r/PythonSoftwareFoundationNew/~3/T3r7qZxo-xg/python-software-foundation-fellow.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/lE0u-5MIUQc/why-sponsor-pycon-2020.html http://feedproxy.google.com/~r/PythonSoftwareFoundationNews/~3/jAMRqiPhWSs/seeking-developers-for-paid-contract.html 例子中实现了 __aiter__() 方法的 AsyncLinkFinder 就是一个异步可迭代对象，__aiter__() 方法返回的必须是一个异步迭代器，如 AsyncLinkIiterator。异步迭代器必须同时实现 __aiter__() 和 __anext__() 方法。一个不同的点是，异步迭代中，当迭代器耗尽时，需要引发一个 StopAsyncIteration 而不是 StopIteration。 同样的，我们也实现一个异步生成器版本的： class LinkFinder: PATTERN = &amp;#34;(?&amp;lt;=href=\&amp;#34;).+?(?=\&amp;#34;)|(?&amp;lt;=href=\&amp;#39;).+?(?=\&amp;#39;)&amp;#34; def __init__(self, text): self.links = re.finditer(self.PATTERN, text) async def __aiter__(self): return (link.group() for link in self.links) 注 ① 关于迭代器的介绍可阅读 Python 可迭代对象, 迭代器和生成器。 ② 关于示例中 __slots__ 的介绍请查看 理解 Python 类属性之 __slots__。 参考 PEP 492: Coroutines with async and await syntax PEP 342: Coroutines via Enhanced Generators</description>
    </item>
    
  </channel>
</rss>